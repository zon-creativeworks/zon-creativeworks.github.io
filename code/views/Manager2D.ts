import * as Tone from 'tone';
import * as THREE from 'three';
import { SVGLoader } from 'three/examples/jsm/loaders/SVGLoader';
import * as PIXI from 'pixi.js';
import * as PUtils from '@pixi/utils';

export default class Manager2D {
  public isMobile: boolean;
  public res: {w: number, h: number};

    // The canvas texture generated by this class
  private outTexture: THREE.CanvasTexture;

  // Pointer Tracking
  public cursor: {x: number, y: number} = { x: 0, y:0 };
  public getCursor(): {x: number, y: number} { return this.cursor };

  private camera: THREE.OrthographicCamera;
  private renderer: THREE.WebGLRenderer;
  private scene = new THREE.Scene();

  // // Interactive Element - Callback Boilerplate
  // public handleInteraction(area: Phaser.Geom.Circle, handlers: { 
  //   onHover?: (cPos: {x: number, y: number}) => void, 
  //   onClick?: (cPos: {x: number, y: number}) => void, 
  //   onTouch?: (cPos: {x: number, y: number}) => void
  // }): void {
  //   const isHover = area.contains(this.cursor.x, this.cursor.y);
  //   const isClick = isHover && this.input.activePointer.isDown;
  //   const isTouch = this.input.mousePointer.wasTouch;
  //     if (isHover && handlers.onHover) handlers.onHover(this.getCursor());
  //     else
  //     if ((isClick || isTouch) && handlers.onClick) handlers.onClick(this.getCursor());
  //     else
  //     if (isTouch && handlers.onTouch) handlers.onTouch(this.getCursor());
  // }

  constructor() {
    this.res = {
      w: window.innerWidth, 
      h: window.innerHeight,
    };

    // next phase
    this.load();
  }

  load(): void {
    const svgLoader = new SVGLoader();
    const texLoader = new THREE.TextureLoader();


    // next phase
    this.setup();
  }

  setup(): void {
    const target = new OffscreenCanvas(this.res.w, this.res.h);
    const pixi = new PIXI.Application({ 
      width: window.innerWidth, 
      height: window.innerHeight,
      antialias: true,
      autoStart: true,
      backgroundAlpha: 0.09,
      backgroundColor: 0xFF00FF,
      hello: true,
      resolution: window.devicePixelRatio,
      sharedTicker: true,
    });


    this.camera = new THREE.OrthographicCamera(-this.res.w / 2, +this.res.w / 2, -this.res.h / 2, +this.res.h / 2, 1, 100);
    this.renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true, canvas: target });
    this.outTexture = new THREE.CanvasTexture(pixi.view as HTMLCanvasElement);
    
    const flatPlane = new THREE.PlaneGeometry(this.res.w, this.res.h);
    const overlay = new THREE.MeshBasicMaterial({map: this.outTexture, transparent: true, side: THREE.BackSide });
    const UIPlane = new THREE.Mesh(flatPlane, overlay);
    UIPlane.position.set(0, 0, -1);

    this.camera.lookAt(UIPlane.position);
    this.scene.add(UIPlane);

    // Use the screen properties to determine if the device is mobile or not
    /* if orientation is portrait at an angle of 0 degrees, the device is mobile due to candybar design */
    this.isMobile = (
      window.screen.orientation.type === 'portrait-primary' && window.screen.orientation.angle === 0
      ||
      window.screen.orientation.type === 'landscape-primary' && window.screen.orientation.angle === 90
    );

    // next phase
    this.start();
  }

  public getTexture(): void {
    // Animates, updates, then returns each frame of the 2D scene as a canvas textures
  }

  private animate(): void {
    this.outTexture.needsUpdate = true;
    this.renderer.render(this.scene, this.camera);
  }

  private start(): void {
    const update = () => {
      this.animate();
      requestAnimationFrame(update);
    };
    update();
  }
}